;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+STARTUP: overview

* Who is it?
** Me
#+BEGIN_SRC emacs-lisp :tangle yes

(setq user-full-name "Aaron Strick"
      user-mail-address "aaronstrick@gmail.com")

#+END_SRC

** Credentials

#+BEGIN_SRC emacs-lisp :tangle yes
(defmacro my-def-api-key (name host)
    ;; This macro expands to this
    ;;
    ;; (defvar my-key-EXAMPLE nil
    ;;     "API key for EXAMPLE retreived from auth-sources"
    ;; )
    ;;
    ;; (defun my-get-key-EXAMPLE ()
    ;;   (let ((key (auth-source-pick-first-password :host EXAMPLE_HOST)))
    ;;     (if key
    ;;         (setq my-key-EXAMPLE key)
    ;;         (message "EXAMPLE API key not found!")
    ;;         nil
    ;;     )))
  `(progn
     (defvar ,(intern (format "my-key-%s" name)) nil
       ,(format "API key for %s retrieved from auth-sources." name))

     (defun ,(intern (format "my-get-key-%s" name)) ()
       (let ((key (auth-source-pick-first-password :host ,host)))
         (if key
             (setq ,(intern (format "my-key-%s" name)) key)
           (progn
             (message "%s API key not found!" ,name)
             nil))))))

(my-def-api-key openai "api.openai.com")
(my-def-api-key anthropic "console.anthropic.com")

(after! auth-source
  (my-get-key-openai)
  (my-get-key-anthropic))

#+END_SRC

* Load Paths

For example $DOOM_DIR/packages/my_package/files.el

#+BEGIN_SRC emacs-lisp :tangle yes

(let ((default-directory (expand-file-name "packages" doom-private-dir)))
  (normal-top-level-add-subdirs-to-load-path))

(add-to-list 'custom-theme-load-path
  (expand-file-name "themes/" doom-user-dir))


#+END_SRC

* Appearances

#+BEGIN_SRC emacs-lisp :tangle yes

(setq doom-font (font-spec :family "Fira Code" :size 14))
(setq doom-variable-pitch-font (font-spec :family "Fira Sans" :size 14)) 

;; (setq doom-theme 'doom-horizon)
;; (setq doom-theme 'strick-light)
(setq doom-theme 'strick)

#+END_SRC

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. To use relative line numbers, set this to `relative'.
#+BEGIN_SRC emacs-lisp :tangle yes

(setq display-line-numbers-type t)
(setq frame-title-format nil)
(add-hook 'emacs-startup-hook #'toggle-frame-maximized)
(use-package! hide-mode-line
  :config
  (global-hide-mode-line-mode 1))

(use-package! perfect-margin)


#+END_SRC

** Cleanup dired a bit

#+BEGIN_SRC emacs-lisp :tangle yes

(add-hook 'dired-mode-hook #'dired-hide-details-mode)

#+END_SRC
** Popups
#+BEGIN_SRC emacs-lisp :tangle yes

(add-to-list 'display-buffer-alist
             '("\\*info\\*"
               (display-buffer-in-side-window)
               (window-width . 0.33)
               (side . right))
             )
(add-to-list 'display-buffer-alist
             '("\\*ChatGPT\\*"
               (display-buffer-in-side-window)
               (window-width . 0.5)
               (side . right))
             )
#+END_SRC

* Misc
** Hacks
#+BEGIN_SRC emacs-lisp :tangle yes
;; I needed this to get some EWW webpages to load.
;; I don't really use that anymore, but I feel like this is a reasonable fix to keep.
(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+END_SRC
** Funcs
#+begin_src elisp :tangle yes
(setq world-clock-list
      '(("America/Los_Angeles" "San Francisco")
       ("America/New_York" "New York")
       ("Europe/Paris" "Paris")))

#+end_src

* Bindings

#+BEGIN_SRC emacs-lisp :tangle yes

(map!
    :leader
    :desc "Project Eshell" :gn "p SPC" #'project-eshell
    :desc "Toggle modeline" :gn "t m" #'global-hide-mode-line-mode
    :desc "dirvish" :gn "-" #'dirvish
    :desc "Expand Region" :gn "v" #'er/expand-region
    )
#+END_SRC

* Completion


#+begin_src emacs-lisp :tangle yes
; TODO I really don't have a handle on the autocomplete stuff...

(after! corfu
  (setq corfu-auto nil)
  )

(map! :i "C-SPC" #'completion-at-point)

#+end_src

* Code Languages
** LSP

#+begin_src emacs-lisp :tangle yes

(after! lsp-mode
  (setq lsp-lens-enable nil)
  (setq lsp-ui-doc-enable nil)
  (setq lsp-ui-sideline-enable nil)
  )

(map!
    :leader
    :desc "Next error" :gn "e j" #'flycheck-next-error
    :desc "Previous error" :gn "e k" #'flycheck-previous-error
    :desc "List errors" :gn "e l" #'flycheck-list-errors
    )

#+end_src
** Typescript
#+begin_src emacs-lisp :tangle yes

;; enable typescript-tslint checker
(after! flycheck
  (flycheck-add-mode 'javascript-eslint 'web-mode)
 )
#+end_src
** Elm
#+begin_src emacs-lisp :tangle yes

;;;###autoload
(defun strk/elm-yank-import-from-module ()
  "Find the Elm `module` declaration in the current buffer and yank an `import` line.

Example:
  Buffer: module This.Is.A.Module exposing (..)
  Yanked:  import This.Is.A.Module

The import string is pushed into `kill-ring`. If Emacs is running in a GUI,
the clipboard (CLIPBOARD selection) is also set. The function errors if not
in an Elm buffer or if no module declaration is found."
  (interactive)
  ;; Basic Elm-buffer check: either elm-mode or .elm file
  (unless (or (eq major-mode 'elm-mode)
              (and buffer-file-name (string-match-p "\\.elm\\'" buffer-file-name)))
    (user-error "Not in an Elm buffer"))
  (save-excursion
    (goto-char (point-min))
    ;; Allow optional lowercase modifiers (e.g. "port module") before 'module'
    (if (re-search-forward
         "^\\s-*\\(?:[a-z]+\\s-+\\)*module\\s-+\\([A-Za-z0-9_.']+\\)" nil t)
        (let* ((mod (match-string 1))
               (import-line (format "import %s" mod)))
          (kill-new import-line)
          (when (fboundp 'gui-set-selection)
            (ignore-errors (gui-set-selection 'CLIPBOARD import-line)))
          (message "Yanked: %s" import-line))
      (user-error "No module declaration found in buffer"))))

(after! elm-mode
  (map! :map elm-mode-map
        :leader
        :desc "Elm: yank import from module"
        "m f y" #'strk/elm-yank-import-from-module))

#+end_src

* LLMs
** Agent Shell
#+begin_src emacs-lisp :tangle yes

(use-package! agent-shell
  :config
  (require 'acp) ;; I think this is necessary
  (setq agent-shell-openai-authentication
      (agent-shell-openai-make-authentication
       :api-key (lambda () (auth-source-pick-first-password :host "api.openai.com")))))
#+end_src

** ChatGPT Shell
#+begin_src emacs-lisp :tangle yes

(use-package! chatgpt-shell
  :config
  (setq chatgpt-shell-model-version "gpt-5")
  (setq chatgpt-shell-openai-key
        (lambda ()
            (auth-source-pick-first-password :host "api.openai.com")))

  (setq chatgpt-shell-always-create-new nil))
#+end_src
** Copilot
 #+begin_src emacs-lisp :tangle yes
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind
    (:map copilot-completion-map
              ("M-l" . 'copilot-accept-completion)
              ("C-l" . 'copilot-accept-completion-by-word)
              )
  :config
  (add-to-list 'copilot-indentation-alist '(elm-mode . 4))
  (setq copilot-indent-offset-warning-disable t)
  (setq copilot-max-char-warning-disabled t)
  (setq copilot-node-executable "/Users/aaronstrick/.local/share/mise/installs/node/20/bin/node")

  ;; https://github.com/emacs-lsp/lsp-mode/issues/4679
  (setq lsp-copilot-applicable-fn (lambda (&rest _) nil))
  )

(setq lsp-completion-provider :capf)
#+end_src

** GPTel
#+begin_src emacs-lisp :tangle yes
(use-package! gptel
 :config
 (setq gptel-api-key my-key-openai)
 (setq gptel-default-mode 'org-mode)

 (gptel-make-anthropic "Claude" :stream t :key my-key-anthropic)

 (gptel-make-tool
    :function (lambda (url)
                (with-current-buffer (url-retrieve-synchronously url)
                (goto-char (point-min))
                (forward-paragraph)
                (let ((dom (libxml-parse-html-region (point) (point-max))))
                    (run-at-time 0 nil #'kill-buffer (current-buffer))
                    (with-temp-buffer
                    (shr-insert-document dom)
                    (buffer-substring-no-properties (point-min) (point-max))))))
    :name "read_url"
    :description "Fetch and read the contents of a URL"
    :args (list '(:name "url"
                :type string
                :description "The URL to read"))
    :category "web")

(defun gptel-read-documentation (symbol)
  "Read the documentation for SYMBOL, which can be a function or variable."
  (let ((sym (intern symbol)))
    (cond
     ((fboundp sym)
      (documentation sym))
     ((boundp sym)
      (documentation-property sym 'variable-documentation))
     (t
      (format "No documentation found for %s" symbol)))))

(gptel-make-tool
 :name "read_documentation"
 :function #'gptel-read-documentation
 :description "Read the documentation for a given function or variable"
 :args (list '(:name "name"
               :type string
               :description "The name of the function or variable whose documentation is to be retrieved"))
 :category "emacs")

 )

  #+end_src

* Notetaking
#+begin_src emacs-lisp :tangle yes

(use-package! denote
  :config
  (setq denote-directory "~/brain/denote")
  )

(setq deft-directory "~/brain")
(setq deft-recursive t)
(setq deft-use-filename-as-title t)
(map!
    :leader
    :desc "Deft File" :gn "n f" #'deft-find-file)


;; https://emacs.stackexchange.com/questions/71100/pasting-images-from-clipboard-into-orgmode
(after! org-download
      (setq org-download-method 'directory)
      (setq org-download-image-dir (concat (file-name-sans-extension (buffer-file-name)) "-img"))
      (setq org-download-image-org-width 600)
      (setq org-download-link-format "[[file:%s]]\n"
        org-download-abbreviate-filename-function #'file-relative-name)
      (setq org-download-link-format-function #'org-download-link-format-function-default))

(after! org-journal
  (setq org-journal-dir "~/brain/Inbox/")
  (setq org-journal-file-format "%Y-%m-%d.md")
  (setq org-journal-date-format "%Y-%m-%d")
  (setq org-journal-date-prefix "# ")
  (setq org-journal-time-prefix "\n## ")
  )
#+end_src
* Presentations
- https://systemcrafters.net/emacs-tips/presentations-with-org-present/
  
#+begin_src elisp :tangle yes
(use-package! keycast)

(use-package! org-present
  :config
  (defun my/org-present-prepare-slide (buffer-name heading)
    ;; Show only top-level headlines
    (org-overview)
    ;; Unfold the current entry
    (org-show-entry)
    ;; Show only direct subheadings of the slide but don't expand them
    (org-show-children))

  (defun my/org-present-start ()
    (beginning-of-buffer)
    (setq my-presentation-original-linenumbers display-line-numbers)
    (setq display-line-numbers nil)
    (keycast-header-line-mode t)
    (org-present-big))

  (defun my/org-present-end ()
    (setq display-line-numbers my-presentation-original-linenumbers)
    (keycast-header-line-mode -1)
    (org-present-small))

  ;; Register hooks with org-present
  (add-hook 'org-present-after-navigate-functions 'my/org-present-prepare-slide)
  (add-hook 'org-present-mode-hook 'my/org-present-start)
  (add-hook 'org-present-mode-quit-hook 'my/org-present-end)
  )

#+end_src

* Habits
I've been using[[https:xenodium.com][ xenodium]]'s flat habits, but I want to be able to super quickly mark things on my computer. org-habit weirdly doesn't seem to have support for this... I guess because they expect you to fully be on org mode (which I'm not). So this code allows me to update the habits
#+begin_src emacs-lisp :tangle yes

(use-package! org-habit-stats)

(setq strk/habit-file "~/Library/Mobile Documents/com~apple~CloudDocs/Org/my-habits.org")
(after! org
  (add-to-list 'org-modules 'org-habit)
  (add-to-list 'org-agenda-files strk/habit-file))

(defun strk/_habit-candidates ()
  "Return an alist of (HEADING . MARKER) for all headings with STYLE=\"habit\" in `strk/habit-file'."
  (let* ((file (expand-file-name strk/habit-file))
         (buf (find-file-noselect file)))
    (with-current-buffer buf
      (org-mode) ;; ensure org functions are available
      (let (result)
        (org-map-entries
         (lambda ()
           ;; store a copy-marker so it stays valid across buffer changes
           (let ((title (org-get-heading t t t t))
                 (m (copy-marker (point))))
     (push (cons title m) result)))
         "STYLE=\"habit\"" ;; match entries marked as habits
         'file)
        (nreverse result))))) ;; return in buffer order

;;;###autoload
(defun strk/habits-open-file ()
    "Open my habit file"
    (interactive)
    (find-file strk/habit-file))


;;;###autoload
(defun strk/habits-mark-done ()
  "Prompt for a habit (from `strk/habit-file') and mark the chosen one DONE.

This uses the headline text for completion. When the headline is marked DONE,
Org's normal state-change/logging code will run (so REPEAT_TO_STATE, LOGGING,
and repeaters like .+1d are respected). The habit file is saved afterward."
  (interactive)
  (let* ((cands (strk/_habit-candidates)))
    (unless cands
      (user-error "No habits found in %s" strk/habit-file))
    (let* ((names (mapcar #'car cands))
           (choice (completing-read "Habit: " names nil t))
           (marker (cdr (assoc choice cands))))
      (unless marker
        (user-error "Selection not found"))
      (let ((buf (marker-buffer marker)))
        (unless (buffer-live-p buf)
          (user-error "Buffer for habit file not available"))
        (with-current-buffer buf
          ;; go to the heading and mark DONE
          (goto-char (marker-position marker))
          (org-back-to-heading t)
          ;; Use a canonical DONE keyword; if you have different keywords,
          ;; you can change "DONE" to your desired keyword or compute it.
          (org-todo "DONE")
          (save-buffer)))
      (message "Marked habit %s DONE" choice))))

  ;;;###autoload
  (defun strk/habits-get-stats ()
    "Interactively select a habit using strk/_habit-candidates and open
  org-habit-stats buffer."
    (interactive)
    (let* ((cands (strk/_habit-candidates)))
      (unless cands
          (user-error "No habits found in %s" strk/habit-file))
        (let* ((names (mapcar #'car cands))
               (choice (completing-read "Habit: " names nil t))
               (marker (cdr (assoc choice cands))))
          (unless marker
            user-error "Selection not found")
          (let ((buf (marker-buffer marker)))
            (with-current-buffer buf
              (goto-char (marker-position marker))
              (org-back-to-heading t)
              (let* ((habit-name (org-element-property :raw-value
  (org-element-at-point)))
                     (habit-data (org-habit-stats-parse-todo (point)))
                     (habit-description (org-entry-get (point) "DESCRIPTION")))
                (print habit-data)
                (org-habit-stats-create-habit-buffer habit-data habit-name
  habit-description 'file)))))))

(map!
   :leader
   :desc "Open Habit File" :gn "d f" #'strk/habits-open-file
   :desc "Capture Habit" :gn "d c" #'strk/habits-mark-done
   :desc "Habit Stats" :gn "d s" #'strk/habits-get-stats)
#+end_src

  :config

#+END_SRC
